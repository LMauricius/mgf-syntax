# --- Modules --------------------------------------------------------------------------------------
[import]standard_
[using]standard_[selection](
    [optional]() [repeat]() [range]()[to]()
    [first]() [shortest_first]() [longest_first]()
    [set]()[to]() [temp]() [push]():()
    [preprocess]()[then]...
    [get]().(...)
)

# --- Macros and aliases ---------------------------------------------------------------------------
[scope]num_[contains](
    [include]standard_values_number_
)

[scope]class_[contains](
    [include]standard_values_class_
)

[scope]field_[contains](
    [include]standard_field
)

Pattern? = [optional]Pattern
Pattern* = [repeat]{0+}:Pattern
Pattern+ = [repeat]{1+}:Pattern
First-Last = [range]First[to]Last
Name:Pattern = [set]Name[to]Pattern
Name+Pattern = [add_entry]Name (Name[last_entry]):Pattern
Path.(...).Name = [get]Path.(...).Name

Pattern*[until]End = [first](End | (Pattern Pattern*[until](End)))

# --- Tokenizer spec -------------------------------------------------------------------------------
[scope]tokenizer_[contains](
    [include]standard_unicode_characters_
    [include]standard_unicode_categories_short_

    __ = standard_wildchar

    # from https:/www.unicode.org/reports/tr31/tr31-3.html - Default id Syntax
    # exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu|Ll|Lt|Lm|Lo|Nl
    Id_connector = Pc
    Id_continue  = Id_start|Mn|Mc|Nd|Cf
    Id_word      = Id_start ( Id_continue | Id_connector Id_continue )*

    Base_mark  = 0 (b & base:num_2 | o & base:num_8 | x & base:num_16)
    E_mark     = _ ('+'|'-') Nd+
    StartDigit = 1-9|a-f|A-F
    Digit      = 0-9|a-f|A-F

    Escape_sequence = '\' (n|r|t|0)

    SpecialToken =  class_'(' & '('
                 =  class_')' & ')'
                 =  class_'[' & '['
                 =  class_']' & ']'
                 =  class_'{' & '{'
                 =  class_'}' & '}'
                 =  class_'=' & '='
                 
    KeywordToken = class_Keyword & (
                        class_if    & i f
                      | class_else  & e l s e
                      | class_while & w h i l e
                    )
        
    TextualToken = class_Identifier & Id_word
                 = class_Number & (
        Base_mark?
        (0 | StartDigit Digit*)
        ('.' (_ | Digit)+)?
        E_mark?
    )
                 = class_String & (
        '"' (Escape_sequence | __)*[until]'"'
    )
                 = class_RawString & (
        [temp]Term
        r (Id_word Term:match_span) '"'
        __*[until]('"' Term)
    )

    NewlineToken = class_Newline & (    
        LF                     # Normal newline
        | '/' '/' __*[until]LF # Singleline comment
    )+ # Count multiple empty lines as a single newline

    MultilineComment = '/' '*' ([first](MultilineComment | __))*[until]('*' '/')

    Ignorable = SP | CR | TAB    # Space
              = MultilineComment # Multiline comment

    AnyToken = span:match_span (
        SpecialToken | KeywordToken | TextualToken | NewlineToken
    )
    Tokens = (
        [longest_first](
            stream+AnyToken
            | Ignorable
        )
    )*
)


# --- Parser spec ----------------------------------------------------------------------------------
[scope]parser_[contains](
    '(' = [test]class_'('
    ')' = [test]class_')'
    '[' = [test]class_'['
    ']' = [test]class_']'
    '{' = [test]class_'{'
    '}' = [test]class_'}'
    '=' = [test]class_'='
    
    if    = [test]class_if
    else  = [test]class_else
    while = [test]class_while
    
    Identifier = [test]class_Identifier
    Number     = [test]class_Number
    String     = [test]class_String
    RawString  = [test]class_RawString
    Newline    = [test]class_Newline

    Expression = Number
               = String
               = '(' Expression ')'
    VariableDeclaration = varName:Identifier ':' type:Expression '=' value:Expression
                        = varName:Identifier '=' value:Expression
    FunctionCall = funcName:Identifier '(' args+Expression (',' args+Expression)* ')'
    Statement = VariableDeclaration | FunctionCall | IfStatement

    IfStatement = (
                    if '(' condition:Expression ')'
                    '{' body:Program '}'
                    (
                        else '{' alternative:Program '}'
                    )?
                )

    Program = class_File & (Statement Newline)+ # Todo: finish program specification
)

Program = [preprocess]tokenizer_Tokens.stream[then]parser_Program