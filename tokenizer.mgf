# --- Modules --------------------------------------------------------------------------------------
[import]standard_
[using]standard_[selection](
    [optional]() [repeat]() [range]()[to]()
    [first]() [shortest]() [longest]() [shortest_first]() [longest_first]()
    [set]()[to]() [temp]() [push]():()
    [preprocess]()[then]...
    [get]().(...)
)

# --- Macros and aliases ---------------------------------------------------------------------------
[scope]num_[contains](
    [include]standard_number_
)

[scope]class_[contains](
    [include]standard_class_
)

[scope]field_[contains](
    [include]standard_field
)

Pattern? = [optional]Pattern
Pattern* = [repeat]{0+}:Pattern
Pattern+ = [repeat]{1+}:Pattern
First-Last = [range]First[to]Last
Name:Pattern = [set]Name[to]Pattern
Name+:Pattern = [add_entry]Name (Name[last_entry]):Pattern
Path.(...).Name = [get]Path.(...).Name

Pattern*[until]End = [first](End | (Pattern Pattern*[until](End)))

# --- Tokenizer spec -------------------------------------------------------------------------------
[scope]tokenizer_[contains](
    [include]standard_unicode_characters_
    [include]standard_unicode_categories_short_

    Any = standard_any_input

    # from https:/www.unicode.org/reports/tr31/tr31-3.html - Default id Syntax
    # exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu|Ll|Lt|Lm|Lo|Nl
    Id_connector = Pc
    Id_continue  = Id_start|Mn|Mc|Nd|Cf
    Id_word      = Id_start ( Id_continue | Id_connector Id_continue )*

    Base_mark  = 0 (b & field_base:num_2 | o & field_base:num_8 | x & field_base:num_16)
    E_mark     = _ ('+'|'-') Nd+
    StartDigit = 1-9|a-f|A-F
    Digit      = 0-9|a-f|A-F

    Escape_sequence = '\' (n|r|t|0)

    Parenthese = '(' [output]class_'('
               = ')' [output]class_')'
               = '[' [output]class_'['
               = ']' [output]class_']'
               = '{' [output]class_'{'
               = '}' [output]class_'}'

    Symbol = '=' [output]class_'='
           = '+' [output]class_'+'
           = '-' [output]class_'-'
           = '*' [output]class_'*'
           = '/' [output]class_'/'
                 
    Keyword = i f       [output](class_Keyword & class_if)
            = e l s e   [output](class_Keyword & class_else)
            = w h i l e [output](class_Keyword & class_while)

    Identifier = Id_word [output]class_Identifier
    Number = [output]class_Number (
        Base_mark?
        (0 | StartDigit Digit*)
        ('.' (_ | Digit)+)?
        E_mark?
    )
    String = '"' (Escape_sequence | Any)*[until]'"' [output]class_String
    RawString = [output]class_RawString (
        [temp]Term
        r (Id_word field_Term:match_span) '"'
        Any*[until]('"' Term)
    )

    Newline = LF                    # Normal newline
            = '/' '/' Any*[until]LF # Singleline comment

    Newlines = Newline+ [output]class_Newlines

    MultilineComment = '/' '*' ([first](MultilineComment | Any))*[until]('*' '/')

    Ignorable = SP | CR | TAB    # Space
              = MultilineComment # Multiline comment

    Token = Parenthese
          = Symbol
          = Keyword
          = Identifier
          = Number
          = String
          = RawString
    Tokens = (
        [longest_first](
            field_stream+:AnyToken
            | Ignorable
        )
    )*
)


# --- Parser spec ----------------------------------------------------------------------------------
[scope]parser_[contains](
    [using]class_[selection](
        '(' ')'
        '[' ']'
        '{' '}'
        '='
        if else while
        Identifier Number String RawString Newline
    )

    Expression = Number
               = String
               = '(' Expression ')'
    VariableDeclaration = field_name:Identifier ':' field_type:Expression '=' field_value:Expression
                        = field_name:Identifier '=' field_value:Expression
    FunctionCall = field_funcName:Identifier '(' field_args+:Expression (',' field_args+:Expression)* ')'
    Statement = VariableDeclaration | FunctionCall | IfStatement

    IfStatement = (
                    if '(' field_condition:Expression ')'
                    '{' field_body:Program '}'
                    (
                        else '{' field_alternative:Program '}'
                    )?
                )

    Program = [output]class_File (Statement Newline)+ # field_Todo: finish program specification
)

Program = [preprocess]tokenizer_Tokens.stream[then]parser_Program