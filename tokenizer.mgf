# --- Modules --------------------------------------------------------------------------------------
[import]standard_
[using]standard_::(
    [optional]() [repeat]() [range]()[to]()
    [first]() [shortest_first]() [longest_first]()
    [class]() [match_classes_from]()
    [field]():() [temp]() [push]():()
    [multistep]()->...
)

# --- Macros and aliases ---------------------------------------------------------------------------
Pattern? = [optional]:Pattern
Pattern* = [repeat]{0+}:Pattern
Pattern+ = [repeat]{1+}:Pattern
First-Last = [range]First[to]Last
Name:Pattern = [field]Name:Pattern
Name+:Pattern = [push]Name:Pattern

Pattern*[until]End = [first](End | (Pattern Pattern*[until](End)))

# --- Tokenizer spec -------------------------------------------------------------------------------
[scope]tokenizer_::(
    [include]standard_unicode_characters_
    [include]standard_unicode_categories_short_

    __ = standard_wildchar
    [class_word]Pattern = [class]Pattern [standard_unicode_string]Pattern

    # from https:/www.unicode.org/reports/tr31/tr31-3.html - Default id Syntax
    # exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu|Ll|Lt|Lm|Lo|Nl
    Id_connector = Pc
    Id_continue  = Id_start|Mn|Mc|Nd|Cf
    Id_word      = Id_start ( Id_continue | Id_connector Id_continue )*

    Base_mark  = 0 (b|o|x)
    E_mark     = _ ('+'|'-') Nd+
    StartDigit = 1-9|a-f|A-F
    Digit      = 0-9|a-f|A-F

    Escape_sequence = '\' (n|r|t|0)

    SpecialToken =  [class_word]'('
                 =  [class_word]')'
                 =  [class_word]'['
                 =  [class_word]']'
                 =  [class_word]'{'
                 =  [class_word]'}'
                 =  [class_word]'='
                 
    KeywordToken = [class]Keyword (
                        [class_word]if
                      | [class_word]else
                      | [class_word]while
                    )
        
    TextualToken = [class]Identifier Id_word
    =  [class]Number     (
        Base_mark?
        (0 | StartDigit Digit*)
        ('.' (_ | Digit)+)?
        E_mark?
    )
    =  [class]String     (
        '"' (Escape_sequence | __)*[until]'"'
    )
    =  [class]RawString  (
        [temp]Term
        r (Id_word [field]Term:match_span) '"'
        __*[until]('"' Term)
    )

    NewlineToken = [class]Newline (    
        LF                     # Normal newline
        | '/' '/' __*[until]LF # Singleline comment
    )+ # Count multiple empty lines as a single newline

    MultilineComment = '/' '*' ([first](MultilineComment | __))*[until]('*' '/')

    Ignorable = SP | CR | TAB    # Space
              = MultilineComment # Multiline comment

    Token = [field]span:match_span (
        SpecialToken | KeywordToken | TextualToken | NewlineToken
    )
    Token_stream =  (
                        [longest_first](
                            [push].:Token
                          | Ignorable
                        )
                    )*
)


# --- Parser spec ----------------------------------------------------------------------------------
[scope]parser_::(
    [match_classes_from]tokenizer_Token

    Expression  = Number
                = String
                = '(' Expression ')'
    VariableDeclaration = (
        varName:Identifier
        ':'
        type:Expression
        '='
        value:Expression
    )
    = varName:Identifier '=' value:Expression
    FunctionCall = funcName:Identifier '(' args+:Expression (',' args+:Expression)* ')'
    Statement = VariableDeclaration | FunctionCall | IfStatement

    IfStatement = (
                    if '(' condition:Expression ')'
                    '{' body:Program '}'
                    (
                        else '{' alternative:Program '}'
                    )?
                )

    Program = [class]File (Statement Newline)+ # Todo: finish program specification
)

Program_string = [multistep]tokenizer_Token_stream->parser_Program