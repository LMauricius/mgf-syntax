# Short grammar specification explanation:
#   '#' starts a comment, till the end of the line
#   Parentheses ( ) enclose a group
#       A group can span multiple lines
#   Space separates items in a group
#   The meaning of groups is context-sensitive, depending where they are passed
#       i.e. the groups are parsed as-they-are
#       Special meanings are interpreted just-in-time
#   Slash | or pipe | are for alternatives in a matching context
#       First matching is applied when using |, all matches are applied when using |
#   A dot . or a group after an identifier with no spaces makes a macro expansion.
#       Multiple arguments are done by just adding them after the previous one
#       Macros also work as function calls, or have special meaning in a context
#   Equals = is for defining a macro inside a scope context
#       A macro can be without arguments, called a pure expansion
#       A macro can be defined with arguments, like a function
#       The arguments become new macros that exist only in the definition context
#       If the right side has multiple items, they are treated as a group
#       If the right side has only 1 item, the macro expands into that item
#       An alias is defined with no arguments, and a single item as the expression
#       An alias can be called with arguments, which are passed to the aliased macro
#   
# Interpretation is context-sensitive. Multiple contexts can be active simultaneously:
#    - Matching context - has properties related to input matching
#    - Scope context - enables defining and including new macros
#    - Definition context - used in right-hand-sides of macro definitions
#    - Object context - modifies a value that gets defined by interpretation and then returned
#    - Parsing context - contains an input stream ducontains an input stream during parsing
#    - Expansion context - created during macro expansion, child context of the context in which the macro was expanded
#    - etc.
#   
# Built-in macros:
#   Args... - The standard scope - expands into Args... from the standard
#       The other arguments are treated as args for the recursive expansion
#       mgf scope contains:
#           include.Scope - expands into all macros inside the scope
#           scope.Group - expands into a new macro; expanding that macro accesses the scope
#           field.fieldName.Group - In a parsing and object context:
#               parses the group and stores its object into a field of this object context
#           save.fieldName.Group - In a parsing context:
#               parses the group and stores its object into the field of the expansion context
#           stream.fieldName.Group - makes the object context a stream context
#               stores objects appended to the fieldName field inside the group into the stream context
#           list - returns a new list value
#           match_span.Group - In a parsing context:
#               matches the group
#               and returns a span of the input stream,
#               used usually to be saved or appended into a field
#           item.fieldName.Value - Appends the value to the list valued field fieldName
#           
#           optional.Group - Matches either the group or nothing
#           repeat.Count.Group - Matches the Count repetitions of the Group
#               Count can be:
#                   a number,
#                   number+ (at least number repetitions, maybe infinite)
#                   minNumber+-maxNumber (between minNumber and maxNumber repetitions)
#           
#           match_sets.Scope - expands into a new scope containing:
#               the macros from the Scope
#               match set macros: macro1|macro2, like brackets in regex
#               match range macros, macro1-macro2, if a range of values has meaning in this parsing context
#               Example: a-z|A-Z|Nd for common letters and decimal numbers
#           
#           unicode_characters - Scope of single characters macros, as well as the control code abbreviations (LF, CR, SP)
#           unicode_categories_short - Scope of category macros identified by two letters, like Lu for Letter,uppercase
#           unicode_wildchar - Any unicode character
#           
#           class.Name - Introduces a new class, applied to the object context
#           match_classes_from.Scope - Expands into a scope, containing matching macros by classes used in the Scope

# --- Modules --------------------------------------------------------------------------------------
\import<standard_>
\using<standard_>(
    \optional() \repeat() \range()\to()
    \first() \shortest_first() \longest_first()
    \class<()> \match_classes_from()
    \field<()>:() \temp<()> \push<()>:()
    \multistep<()>>()>
)

# --- Macros and aliases ---------------------------------------------------------------------------
Pattern? = \optional:Pattern
Pattern* = \repeat{0+}:Pattern
Pattern+ = \repeat{1+}:Pattern
First-Last = \range(First)\to(Last)
<Name>:Pattern = \field<Name>:Pattern
<Name>+:Pattern = \push<Name>:Pattern

Pattern*\until(End) =  \first(
                            End
                          | (Pattern Pattern*\until(End))
                        )

# --- Tokenizer spec -------------------------------------------------------------------------------
\scope<tokenizer_>:(
    \include<standard_unicode_characters_>
    \include<standard_unicode_categories_short_>

    __ = standard_wildchar
    \class_word<Pattern> = \class<Pattern> \standard_unicode_string"Pattern"

    # from https:/www.unicode.org/reports/tr31/tr31-3.html - Default id Syntax
    # exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu|Ll|Lt|Lm|Lo|Nl
    Id_connector = Pc
    Id_continue  = Id_start|Mn|Mc|Nd|Cf

    Base_mark  = 0 (b|o|x)
    E_mark     = _ ('+'|'-') Nd+
    StartDigit = 1-9|a-f|A-F
    Digit      = 0-9|a-f|A-F

    Escape_sequence = '\' (n|r|t|0)

    SpecialToken =  \class_word<'('>
                 =  \class_word<')'>
                 =  \class_word<'['>
                 =  \class_word<']'>
                 =  \class_word<'{'>
                 =  \class_word<'}'>
                 =  \class_word<'='>
                 
    KeywordToken = \class<Keyword> (
                        \class_word<if>
                      | \class_word<else>
                      | \class_word<while>
                    )
        
    TextualToken
    =  \class<Identifier> (
        Id_start ( Id_continue | Id_connector Id_continue )*
    )
    =  \class<Number>     (
        Base_mark?
        (0 | StartDigit Digit*)
        ('.' (_ | Digit)+)?
        E_mark?
    )
    =  \class<String>     (
        '"' (Escape_sequence | __)*\until('"')
    )
    =  \class<RawString>  (
        \temp<Term>
        r (identifier \field<Term>:match_span) '"'
        __*\until('"' Term)
    )

    NewlineToken =  \class<Newline> (    # Count multiple empty lines as a single newline
                        LF                    # Normal newline
                      | '/' '/' __*\until(LF) # Singleline comment
                    )+

    MultilineComment = '/' '*' ({first}(MultilineComment | __))*\until('*' '/')

    Ignorable = SP | CR | TAB    # Space
              = MultilineComment # Multiline comment

    Token = \class<Token> \field<span>:match_span (
        SpecialToken | KeywordToken | TextualToken | NewlineToken
    )
    Token_stream =  (
                        {(longest|first)}(
                            \push<.>:Token
                          | Ignorable
                        )
                    )*
)


# --- Parser spec ----------------------------------------------------------------------------------
\scope<parser_>:(
    \match_classes_from(tokenizer_Token)

    Expression  = Number
                = String
                = '(' Expression ')'
    VariableDeclaration
    = (
        \field<varName>:Identifier
        ':'
        \field<expr>:Expression
        '='
        \field<expr>:Expression
    )
    = \field<varName>:Identifier '=' \field<expr>:Expression
    FunctionCall =  (
                        \field<funcName>:Identifier
                        (
                            \push<args>:Expression
                            (',' \push<args>:Expression)*
                        )
                    )
    Statement = VariableDeclaration | FunctionCall | IfStatement

    IfStatement = (
                    if '(' <condition>:Expression ')'
                    '{' <body>:Program '}'
                    (
                        else '{' <alternative>:Program '}'
                    )?
                )

    Program = \class<File> (Statement Newline)+ # Todo: finish program specification
)

Program_string = \multistep<tokenizer_Token_stream>>parser_Program>