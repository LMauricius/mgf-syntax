# Short grammar specification explanation:
#   '#' starts a comment, till the end of the line
#   Parentheses ( ) enclose a group
#       A group can span multiple lines
#   Space separates items in a group
#   The meaning of groups is context-sensitive, depending where they are passed
#       i.e. the groups are parsed as-they-are
#       Special meanings are interpreted just-in-time
#   Slash / or pipe | are for alternatives in a matching context
#       First matching is applied when using /, all matches are applied when using |
#   A dot . or a group after an identifier with no spaces makes a macro expansion.
#       Multiple arguments are done by just adding them after the previous one
#       Macros also work as function calls, or have special meaning in a context
#   Equals = is for defining a macro inside a scope context
#       A macro can be without arguments, called a pure expansion
#       A macro can be defined with arguments, like a function
#       The arguments become new macros that exist only in the definition context
#       If the right side has multiple items, they are treated as a group
#       If the right side has only 1 item, the macro expands into that item
#       An alias is defined with no arguments, and a single item as the expression
#       An alias can be called with arguments, which are passed to the aliased macro
#   
# Interpretation is context-sensitive. Multiple contexts can be active simultaneously:
#    - Matching context - has properties related to input matching
#    - Scope context - enables defining and including new macros
#    - Definition context - used in right-hand-sides of macro definitions
#    - Object context - modifies a value that gets defined by interpretation and then returned
#    - Parsing context - contains an input stream ducontains an input stream during parsing
#    - Expansion context - created during macro expansion, child context of the context in which the macro was expanded
#    - etc.
#   
# Built-in macros:
#   mgf.Args... - The standard scope - expands into Args... from the standard
#       The other arguments are treated as args for the recursive expansion
#       mgf scope contains:
#           include.Scope - expands into all macros inside the scope
#           scope.Group - expands into a new macro; expanding that macro accesses the scope
#           field.fieldName.Group - In a parsing and object context:
#               parses the group and stores its object into a field of this object context
#           save.fieldName.Group - In a parsing context:
#               parses the group and stores its object into the field of the expansion context
#           stream.fieldName.Group - makes the object context a stream context
#               stores objects appended to the fieldName field inside the group into the stream context
#           list - returns a new list value
#           match_span.Group - In a parsing context:
#               matches the group
#               and returns a span of the input stream,
#               used usually to be saved or appended into a field
#           item.fieldName.Value - Appends the value to the list valued field fieldName
#           
#           optional.Group - Matches either the group or nothing
#           repeat.Count.Group - Matches the Count repetitions of the Group
#               Count can be:
#                   a number,
#                   number+ (at least number repetitions, maybe infinite)
#                   minNumber+-maxNumber (between minNumber and maxNumber repetitions)
#           
#           match_sets.Scope - expands into a new scope containing:
#               the macros from the Scope
#               match set macros: macro1/macro2, like brackets in regex
#               match range macros, macro1-macro2, if a range of values has meaning in this parsing context
#               Example: a-z/A-Z/Nd for common letters and decimal numbers
#           
#           unicode_characters - Scope of single characters macros, as well as the control code abbreviations (LF, CR, SP)
#           unicode_categories_short - Scope of category macros identified by two letters, like Lu for Letter,uppercase
#           unicode_wildchar - Any unicode character
#           
#           class.Name - Introduces a new class, applied to the object context
#           match_classes_from.Scope - Expands into a scope, containing matching macros by classes used in the Scope

OPT = mgf.optional
0+ = mgf.repeat.0+
1+ = mgf.repeat.1+
?? = mgf.unicode_wildchar

UNTIL.End.Repeated_pattern = End / (Repeated_pattern UNTIL.End.Repeated_pattern)
PATTERN_CLASS.Pattern = mgf.class(Pattern) Pattern
LONGEST.Selection  = mgf.option(Shortest/First).Selection

Token_matching = mgf.scope(
    mgf.include.mgf.match_sets(                 
        mgf.include.mgf.unicode_characters       
        mgf.include.mgf.unicode_categories_short 
    )

    ## from https:/www.unicode.org/reports/tr31/tr31-3.html # Default id Syntax
    ## exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu/Ll/Lt/Lm/Lo/Nl
    Id_connector = Pc
    Id_continue  = Id_start | Mn/Mc/Nd/Cf

    Base_mark = 0 (b|o|x)
    E_mark    = _ (+|-) Nd
    PosDigit  = 1-9|a-f|A-F
    Digit     = Nd|a-f|A-F

    Escape_sequence = \ (n|r|t|0)

    SpecialToken = PATTERN_CLASS.'(
                 | PATTERN_CLASS.')
                 | PATTERN_CLASS.'[
                 | PATTERN_CLASS.']
                 | PATTERN_CLASS.'{
                 | PATTERN_CLASS.'} 
                 | PATTERN_CLASS.'=

    KeywordToken = mgf.class.Keyword (
                        PATTERN_CLASS(i f)
                      | PATTERN_CLASS(e l s e)
                      | PATTERN_CLASS(w h i l e)
                    )
        
    TextualToken = mgf.class.Identifier Id_start 0+(Id_continue | Id_connector Id_continue)
                 | mgf.class.Number     OPT.Base_mark (0 | PosDigit 0+.Digit) OPT('. 1+(_ | Digit)) OPT.E_mark
                 | mgf.class.String     (
                        '" UNTIL.'"(Escape_sequence | ??)
                     | r mgf.save.Term.mgf.MatchSpan.identifier '" UNTIL('" mgf.rematch.Term)(Escape_sequence | ??)
                    )

    NewlineToken = mgf.class.Newline 1+( ## Count multiple empty lines as a single newline
                       LF              ## Normal newline
                    | '# UNTIL.LF.??   ## Singleline comment
                   )

    Ignorable = SP | CR | TAB       ## Space
              | '/ - UNTIL(- '/).?? ## Multiline comment

    Token = mgf.field.span.mgf.MatchSpan.LONGEST(SpecialToken | KeywordToken | TextualToken | NewlineToken)
    Token_stream = mgf.stream.tokens.0+(mgf.item.tokens.Token | Ignorable)
)



Structure_matching = mgf.scope(
    mgf.include.mgf.match_classes_from.Token_matching

    Expression  = Number
                / String
                / ( Expression )
    VariableDeclaration = mgf.field.varName.Identifier = mgf.field.expr.Expression
    FunctionCall = mgf.field.funcName.Identifier mgf.field.args.mgf.list ( mgf.item.args.Expression 0+.(, mgf.item.args.Expression) )
    Statement = VariableDeclaration / FunctionCall
    Program = mgf.class.File 1+.(Statement Newline) ## Todo: finish program specification

    IfStatement = if '( mgf.field.condition.Expression ') : mgf.field.body.Program OPT(else mgf.field.alternative.Program)
)

Program_file = MULTISTEP(Token_matching.Token_stream)(Program)