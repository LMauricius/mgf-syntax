# Short grammar specification explanation:
#   '#' starts a comment, till the end of the line
#   Parentheses ( ) enclose a group
#       A group can span multiple lines
#   Space separates items in a group
#   The meaning of groups is context-sensitive, depending where they are passed
#       i.e. the groups are parsed as-they-are
#       Special meanings are interpreted just-in-time
#   Slash / or pipe / are for alternatives in a matching context
#       First matching is applied when using /, all matches are applied when using /
#   A dot . or a group after an identifier with no spaces makes a macro expansion.
#       Multiple arguments are done by just adding them after the previous one
#       Macros also work as function calls, or have special meaning in a context
#   Equals = is for defining a macro inside a scope context
#       A macro can be without arguments, called a pure expansion
#       A macro can be defined with arguments, like a function
#       The arguments become new macros that exist only in the definition context
#       If the right side has multiple items, they are treated as a group
#       If the right side has only 1 item, the macro expands into that item
#       An alias is defined with no arguments, and a single item as the expression
#       An alias can be called with arguments, which are passed to the aliased macro
#   
# Interpretation is context-sensitive. Multiple contexts can be active simultaneously:
#    - Matching context - has properties related to input matching
#    - Scope context - enables defining and including new macros
#    - Definition context - used in right-hand-sides of macro definitions
#    - Object context - modifies a value that gets defined by interpretation and then returned
#    - Parsing context - contains an input stream ducontains an input stream during parsing
#    - Expansion context - created during macro expansion, child context of the context in which the macro was expanded
#    - etc.
#   
# Built-in macros:
#   st_Args... - The standard scope - expands into Args... from the standard
#       The other arguments are treated as args for the recursive expansion
#       mgf scope contains:
#           include.Scope - expands into all macros inside the scope
#           scope.Group - expands into a new macro; expanding that macro accesses the scope
#           field.fieldName.Group - In a parsing and object context:
#               parses the group and stores its object into a field of this object context
#           save.fieldName.Group - In a parsing context:
#               parses the group and stores its object into the field of the expansion context
#           stream.fieldName.Group - makes the object context a stream context
#               stores objects appended to the fieldName field inside the group into the stream context
#           list - returns a new list value
#           match_span.Group - In a parsing context:
#               matches the group
#               and returns a span of the input stream,
#               used usually to be saved or appended into a field
#           item.fieldName.Value - Appends the value to the list valued field fieldName
#           
#           optional.Group - Matches either the group or nothing
#           repeat.Count.Group - Matches the Count repetitions of the Group
#               Count can be:
#                   a number,
#                   number+ (at least number repetitions, maybe infinite)
#                   minNumber+-maxNumber (between minNumber and maxNumber repetitions)
#           
#           match_sets.Scope - expands into a new scope containing:
#               the macros from the Scope
#               match set macros: macro1/macro2, like brackets in regex
#               match range macros, macro1-macro2, if a range of values has meaning in this parsing context
#               Example: a-z/A-Z/Nd for common letters and decimal numbers
#           
#           unicode_characters - Scope of single characters macros, as well as the control code abbreviations (LF, CR, SP)
#           unicode_categories_short - Scope of category macros identified by two letters, like Lu for Letter,uppercase
#           unicode_wildchar - Any unicode character
#           
#           class.Name - Introduces a new class, applied to the object context
#           match_classes_from.Scope - Expands into a scope, containing matching macros by classes used in the Scope

# --- Modules --------------------------------------------------------------------------------------
\import_as [Prefix]st_ [Module]standard_

# --- Macros and aliases ---------------------------------------------------------------------------
\opt[Pattern] = \st_optional(Pattern)
\**[Pattern] = \st_repeat [Count]0+ [Pattern]Pattern
\++[Pattern] = \st_repeat [Count]1+ [Pattern]Pattern
?? = st_unicode_wildchar

\until[End][Pattern] =  \st_choose [Priority]FIRST [Options](
                            End
                          / (Pattern \until [End]End [Pattern]Pattern)
                        )
\class_word[Pattern] = \st_class(Pattern) \st_unicode_string(Pattern)
\first[Options]  = \st_choose [Priority](st_first) [Options]Options

# --- Tokenizer spec -------------------------------------------------------------------------------
\scope [Prefix]Tokenizer_ [Containing](
    \include(st_unicode_characters_)
    \include(st_unicode_categories_short_)

    \include(\st_match_sets(
        \include(st_unicode_characters_)
        \include(st_unicode_categories_short_)
    ))

    # from https:/www.unicode.org/reports/tr31/tr31-3.html - Default id Syntax
    # exception is the connector punctuation; as only one consecutive is supported
    Id_start     = Lu/Ll/Lt/Lm/Lo/Nl
    Id_connector = Pc
    Id_continue  = Id_start/Mn/Mc/Nd/Cf

    Base_mark  = 0 (b/o/x)
    E_mark     = _ (+/-) Nd
    StartDigit = 1-9/a-f/A-F
    Digit      = 0-9/a-f/A-F

    Escape_sequence = '\' n/r/t/0

    SpecialToken = \class_word('(')
                 / \class_word(')')
                 / \class_word('[')
                 / \class_word(']')
                 / \class_word('{')
                 / \class_word('}')
                 / \class_word('=')

    KeywordToken = \st_class(Keyword) (
                        \class_word(if)
                      / \class_word(else)
                      / \class_word(while)
                    )
        
    TextualToken =  \st_class(Identifier) (
                        Id_start \**( Id_continue / Id_connector Id_continue )
                    )
                  / \st_class(Number)     (
                        \opt(Base_mark)
                        (0 / StartDigit \**(Digit))
                        \opt(. \++(_ / Digit))
                        \opt(E_mark)
                    )
                  / \st_class(String)     (
                        '"' \until [Pattern](Escape_sequence / ??) [End]'"'
                    )
                  / \st_class(RawString)  (
                        r (identifier \st_temp [Name]Term [Pattern]st_match_span) '"'
                        \until [Pattern]?? [End](
                            '"' Term
                        )
                    )

    NewlineToken =  \st_class(Newline) \++(    # Count multiple empty lines as a single newline
                        LF                             # Normal newline
                      / '#' \until [End]LF [Pattern]?? # Singleline comment
                    )

    Ignorable = SP / CR / TAB                         # Space
              / '/' - \until [End](- '/') [Pattern]?? # Multiline comment

    Token = \st_class(Token) \st_field [Name]span [Value]st_match_span (
        SpecialToken / KeywordToken / TextualToken / NewlineToken
    )
    Token_stream =  \st_stream(tokens) \**(
                        \st_choose [Priority](st_longest/st_first) [Options](
                            \st_item [Name]tokens [Value]Token
                        / Ignorable
                        )
                    )
)


# --- Parser spec ----------------------------------------------------------------------------------
\scope[Prefix]Structured_[Containing](
    \include(\st_match_classes_from(Tokenizer_Token))

    Expression  = Number
                / String
                / '(' Expression ')'
    VariableDeclaration =   (
                                \st_field[Name]varName[Value]Identifier
                                '='
                                \st_field[Name]expr[Value]Expression
                            )
    FunctionCall =  (
                        \st_field[Name]funcName[Value]Identifier
                        \st_field[Name]args[Value]st_list (
                            \st_item[Name]args[Value]Expression
                            \**(',' st_item[Name]args[Value]Expression)
                        )
                    )
    Statement = VariableDeclaration / FunctionCall
    Program = \st_class(File) \++(Statement Newline) ## Todo: finish program specification

    IfStatement = (
                    if '(' \st_field[Name]condition[Value]Expression ')'
                    '{' \st_field_body(Program) '}'
                    \opt(
                        else '{' \st_field[Name]alternative[Value]Program '}'
                    )
                )
)

Program_file = \multistep[Step](Tokenizer_Token_stream)[Step]Structured_Program